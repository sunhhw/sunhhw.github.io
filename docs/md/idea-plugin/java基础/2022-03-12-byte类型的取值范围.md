## 一、八大基本类型

| 数据类型        | 字节 | 位数 | 取值范围（有符号） |
| --------------- | ---- | ---- | ------------------ |
| byte(位)        | 1    | 8    | -2^7 ~ 2^7-1       |
| short(短整数)   | 2    | 16   | -2^15 ~ 2^15-1     |
| int(整数)       | 4    | 32   | -2^31 ~ 2^31-1     |
| long(长整数)    | 8    | 64   | -2^63 ~ 2^63-1     |
| float(单精度)   | 4    | 32   | -2^31 ~ 2^31-1     |
| double(双精度)  | 8    | 64   | -2^63 ~ 2^63-1     |
| char(字符)      | 2    | 16   | 0 - 2^16-1         |
| boolean(布尔值) | 1    | 8    | true、false        |

## 二、byte的取值范围是-2^7 ~ 2^7-1？

- 一个字节 = 8位
- 有符号中，最高位表示符号位，0为正数，1为负数
- 无符号中，表示都是正数

### 1.  有符号

首先byte是占有1个字节，在计算中表示8位，在二进制中表达的最大数为 11111111即2^8-1(255)，但是在有符号中最高位表示符号位，所以能有效表示最大数只能是1 **1111111**，2^7-1；

### 2.  0的表示

当然了，按照以上说法，00000000表示+0，10000000表示-0，这在计算中是不被允许的，不可以出现这种一个数被两个二进制表示，所以先说结论：0由00000000表示，而1000000表示-128，即-2^7;

### 3. 原码，反码，补码

在计算机中,

**正数是直接用原码表示的，如单字节5，在计算机中就表示为：0000 0101。
负数以其绝对值的补码形式表示，如单字节-5，在计算机中表示为1111 1011。** 

**原码：**

- **一个正数的原码，是按照绝对值大小转换成的二进制数；**
- **一个负数的原码，是按照绝对值大小转换成的二进制数，然后最高位用1表示负数；**
- 00000101 是单字节5的原；
- 10000101 是单字节5的原码；

**反码：**

- **正数的反码与原码相同**
- **负数的反码为对该数的原码除符号位外各位取反**
- 正数 00000101 的反码还是 00000101
- 负数的 10000101 的反码是11111010

**补码：**

- **正数的补码与原码相同；**
- **负数的补码是该原码的反码，然后在反码的最后一位加1；**
- 正数 00000101 的补码还是 00000101
- 负数的 10000101 的补码是 11111011

**所以综上所述,单字节-5在计算中的表达为:11111011**

### 4. 总结

当为负数时，补码是1000 0000时，我们通过这个补码反向算得反码是0111 1111，原码就是0000 0000是不是感觉很诡异，这不是正0吗？言下之意就是说，补码1000 0000这个二进制位压根不可能有 ；

这时候就需要反着推， -128(取绝对值) -> 128(变成二进制表示) ->1000 0000(取反)->0111 1111(加1) -> 1000 0000(补码) ，所以补码1000 0000就顺利成章的表示-128了，所以byte类型的取值范围就是   -2^7 ~ 2^7-1；





 













